using System.Collections.Generic;
using HearthStoneSimCore.Enchants;
using HearthStoneSimCore.Enums;

namespace HearthStoneSimCore.Model
{
    public abstract class Playable : Core
    {
        /// <summary>
        /// Playable zoneposition.
        /// </summary>
        public int ZonePosition { get; set; }

        public Race Race
        {
            get => (Race)this[GameTag.CARDRACE];
            set => this[GameTag.CARDRACE] = (int)value;
        }

        /// <summary> Gets or sets the entity ID target.</summary>
        /// <value><see cref="Core.Id"/></value>
        public int CardTarget
		{
			get => this[GameTag.CARD_TARGET];
			set => this[GameTag.CARD_TARGET] = value;
		}

		/// <summary>
		/// Playable is overloading mana.
		/// </summary>
		public int Overload
        {
            get => this[GameTag.OVERLOAD];
            set => this[GameTag.OVERLOAD] = value;
        }

        /// <summary>
        /// Gets a value indicating whether this entity will be destroyed during the next cleanup
        /// phase.
        /// </summary>
        private bool _toBeDestroyed;
        public virtual bool ToBeDestroyed
        {
            get => _toBeDestroyed;
            set
            {
                _toBeDestroyed = value;
                this[GameTag.TO_BE_DESTROYED] = value ? 1 : 0;
            }
        }

        /// <summary>
        /// Gets or sets current activated <see cref="Trigger"/> of this entity.
        /// Nullifying this field does not mean deactivation of the trigger.
        /// Use <see cref="Trigger.Remove()"/> instead.
        /// </summary>
        public Trigger ActivatedTrigger { get; set; }

        /// <summary>Mark this entity for destruction.</summary>
        /// <returns>Returns itself.</returns>
        /// <autogeneratedoc />
        public virtual void Destroy()
        {
            ToBeDestroyed = true;
            Game.Log(LogLevel.VERBOSE, BlockType.PLAY, "Playable", $"{this} just got set to be destroyed.");
        }

        protected Playable(Controller controller, Card card, Dictionary<GameTag, int> tags) : base(controller.Game, card, tags)
		{
			Controller = controller;
		}

        // Cloning copy constructor
        protected Playable(Playable cloneFrom) : base(cloneFrom) { }
    }
}
