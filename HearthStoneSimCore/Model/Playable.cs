using System.Collections.Generic;
using HearthStoneSimCore.Enchants;
using HearthStoneSimCore.Enums;

namespace HearthStoneSimCore.Model
{
    public abstract class Playable : Core
    {
	    public List<Enchantment> Enchantment { get; } = new List<Enchantment>();

        /// <summary>
        /// Playable zoneposition.
        /// </summary>
        public int ZonePosition { get; set; }

        public Race Race
        {
            get => (Race)this[GameTag.CARDRACE];
            set => this[GameTag.CARDRACE] = (int)value;
        }

        /// <summary> Gets or sets the entity ID target.</summary>
        /// <value><see cref="Core.Id"/></value>
        public int CardTarget
		{
			get => this[GameTag.CARD_TARGET];
			set => this[GameTag.CARD_TARGET] = value;
		}

		/// <summary>
		/// Playable is overloading mana.
		/// </summary>
		public int Overload
        {
            get => this[GameTag.OVERLOAD];
            set => this[GameTag.OVERLOAD] = value;
        }

        /// <summary>
        /// Gets or sets current activated <see cref="Trigger"/> of this entity.
        /// Nullifying this field does not mean deactivation of the trigger.
        /// Use <see cref="Trigger.Remove()"/> instead.
        /// </summary>
        public Trigger ActivatedTrigger { get; set; }

        /// <summary>
        /// Gets a value indicating whether this entity will be destroyed during the next cleanup
        /// phase.
        /// </summary>
        /// <value><c>true</c> if pending destruction; otherwise, <c>false</c>.</value>
        public bool ToBeDestroyed { get; set; }

        #region Targeting
        public bool NeedsTargetList =>
            Card.RequiresTarget
            || Card.RequiresTargetForCombo
            || Card.RequiresTargetIfAvailable
            || Card.RequiresTargetIfAvailableAndDragonInHand // && Controller.DragonInHand 
            || Card.RequiresTargetIfAvailableAndElementalPlayedLastTurn // && Controller.NumElementalsPlayedLastTurn > 0
            || Card.RequiresTargetIfAvailableAndMinimumFriendlyMinions // && Controller.Board.Count >= 4
            || Card.RequiresTargetIfAvailableAndMinimumFriendlySecrets // && Controller.Secrets.Count > 0;
            || Card.RequiresTargetIfAvailableAndNo3CostCardInDeck;

        #endregion

        /// <summary>Mark this entity for destruction.</summary>
        /// <returns>Returns itself.</returns>
        /// <autogeneratedoc />
        public virtual void Destroy()
        {
            ToBeDestroyed = true;
            Game.Log(LogLevel.VERBOSE, BlockType.PLAY, "Playable", $"{this} just got set to be destroyed.");
        }

        protected Playable(Controller controller, Card card, Dictionary<GameTag, int> tags) : base(controller.Game, card, tags)
		{
			Controller = controller;
			Enchantment.Add(Card.Enchantment);
		}

        // Cloning copy constructor
        protected Playable(Playable cloneFrom) : base(cloneFrom) { }
    }
}
