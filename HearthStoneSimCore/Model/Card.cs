using System.Collections.Generic;
using HearthStoneSimCore.Enchants;
using HearthStoneSimCore.Enums;

namespace HearthStoneSimCore.Model
{
    public class Card
    {
        public int this[GameTag t] => Tags.TryGetValue(t, out int value) ? value : 0;
        /// <summary>
        /// Unique asset id of that card nummeric representation. (ID attribute from CardDefs.xml)
        /// </summary>
        public int AssetId { get; }
        /// <summary>
        /// Unique card ID (CardID attribute from CardDefs.xml)
        /// </summary>
        public string Id { get; private set; }
        public string Name { get; set; }
        public string Text { get; set; }
        public string ArtImageSource => @"d:/CardArt/Full/" + Id + ".png";
        public string FrameImageSource => @"../Images/inhand_minion_druid.png";

        public int ATK { get; private set; }
        public int Health { get; private set; }
        public int SpellPower { get; private set; }
        public bool Taunt { get; private set; }
        public bool Charge { get; private set; }
        public bool Stealth { get; private set; }
        public bool Poisonous { get; private set; }
        public bool DivineShield { get; private set; }
        public bool Windfury { get; private set; }
        public bool LifeSteal { get; private set; }
        public bool Echo { get; private set; }
        public bool Rush { get; private set; }
        public bool CantBeTargetedBySpells { get; private set; }
        public bool CantBeTargetedByHeroPowers => CantBeTargetedBySpells;
        public bool CantAttack { get; private set; }
        public bool Modular { get; private set; }
        public bool ChooseOne { get; private set; }
        public bool Combo { get; private set; }
        public bool IsSecret { get; private set; }
        public bool IsQuest { get; private set; }
        public bool Deathrattle { get; }
        public bool Untouchable { get; private set; }
        public bool HideStat { get; private set; }
        public bool ReceivesDoubleSpelldamageBonus { get; private set; }
        public bool Freeze { get; }

        /// <summary>
        /// Contains all card ID's which are generated by this specific card.
        ///
        /// For example Ysera, the dragon which produces on DREAM card after your turn,
        /// has entourage: DREAM_01, DREAM_02, DREAM_03, DREAM_04, DREAM_05
        /// </summary>
        public string[] Entourage { get; }

        /// <summary>
        /// Properties set on this instance.
        /// These properties represent health, attack, # turns in play etc.
        /// <see cref="GameTag"/> for all possibilities.
        /// </summary>
        public Dictionary<GameTag, int> Tags { get; private set; }

        /// <summary>
        /// Declares all effects that are triggered by this instance.
        /// Possibilities are SpellPower, DeathRattle, Charge etc.
        /// </summary>
        public Dictionary<GameTag, int> RefTags { get; }

        /// <summary>
        /// Requirements that must have been met before this card can be moved into
        /// play zone.
        /// <see cref="PlayReq"/> for all possibilities.
        /// </summary>
        public Dictionary<PlayReq, int> PlayRequirements { get; }

        /// <summary>
        /// Indicates if this card occurs in the player's collection. Only collectible
        /// cards can be put together in a deck.
        ///
        /// Non-collectible cards are generated during the game, like Ysera's Dream cards.
        /// </summary>
        public bool Collectible => this[GameTag.COLLECTIBLE] == 1;

        /// <summary>
        /// A card can have NO class or AT MOST one.
        /// The cardclass is coupled with the chosen hero to represent the player.
        ///
        /// Cards with a specific class can NOT be put into a deck with other classcards.
        /// <seealso cref="CardClass"/>
        /// </summary>
        public CardClass Class { get; }

        /// <summary>
        /// Multi class group.
        /// </summary>
        public int MultiClassGroup => this[GameTag.MULTI_CLASS_GROUP];

        /// <summary>
        /// <see cref="Race"/>
        /// </summary>
        public Race Race { get; }

        /// <summary>
        /// <see cref="Faction"/>
        /// </summary>
        public Faction Faction => (Faction)this[GameTag.FACTION];

        /// <summary>
        /// <see cref="Rarity"/>
        /// </summary>
        public Rarity Rarity => (Rarity)this[GameTag.RARITY];

        /// <summary>
        /// The actual type of a card has limitations on it's usage.
        /// A hero card cannot be put into a deck for example.. imagine that!
        /// Knights of the Frozen Throne , is beyond imagination? With
        /// Deathknigth heros in the deck!
        /// <see cref="CardType"/>
        /// </summary>
        public CardType Type { get; }

        /// <summary>
        /// <see cref="CardSet"/>
        /// </summary>
        public CardSet Set => (CardSet)this[GameTag.CARD_SET];

        /// <summary>
        /// Maximum amount of copies that are allowed in one deck.
        /// </summary>
        public int MaxAllowedInDeck => Rarity == Rarity.LEGENDARY ? 1 : 2;

        /// <summary>
        /// Original mana-cost of this card.
        /// </summary>
        public int Cost { get; }

        /// <summary>
        /// True if this card will incur Overload when played.
        /// Overload is an effect that locks mana crystals.
        /// Locked mana crystals can't be spent during one turn.
        /// </summary>
        public bool HasOverload { get; internal set; }

        /// <summary>
        /// The amount of overload incurred by this card when played.
        /// </summary>
        public int Overload { get; internal set; }

        /// <summary>
        /// True if this card increases it's owners spell damage.
        /// </summary>
        public bool IsAffectedBySpellDamage { get; set; }


        public override string ToString() { return Name; }

        #region Tergeting

        /// <summary>
        /// True if playing this card requires at least one valid target.
        /// </summary>
        public bool MustHaveTargetToPlay { get; }

        /// <summary>
        /// Represents the range of characters in which a card can target.
        /// </summary>
        public TargetingType TargetingType { get; }
        
        /// <summary>
        /// Constraint condition based on the state of a target <see cref="ICharacter"/>.
        /// Returns true if the target is valid for this card.
        /// The result of this predicate is independent of <see cref="TargetingType"/> of this card.
        /// null if there is no such a condtion for this card.
        /// </summary>
        public readonly TargetingPredicate TargetingPredicate;
        
        /// <summary>
        /// Returns true if playing this card requires targeting, based on the given state of a <see cref="Controller"/>.
        /// Can be null.
        /// </summary>
        public readonly AvailabilityPredicate TargetingAvailabilityPredicate;
        
        /// <summary>
        /// Returns false if this card cannot be played with respect to the given state of a <see cref="Controller"/>.
        /// </summary>
        public AvailabilityPredicate PlayAvailabilityPredicate { get; private set; }

        #endregion Targeting

        //default constructor
        public Card()
        {
        }

	    internal static Card CardPlayer => new Card()
	    {
		    Name = "Player",
		    Tags = new Dictionary<GameTag, int> { [GameTag.CARDTYPE] = (int)CardType.PLAYER },
		    //PlayRequirements = new Dictionary<PlayReq, int>(),
	    };

        internal Card(string id, int assetId, Tag[] tags, Dictionary<PlayReq, int> playRequirements,
            string[] entourage, Tag[] refTags)
        {
            Id = id;
            AssetId = assetId;
            Entourage = entourage;
            PlayRequirements = playRequirements;
            var tagDict = new Dictionary<GameTag, int>();
            var refTagDict = new Dictionary<GameTag, int>();

            #region Preprocessing tags.
            foreach (Tag tag in tags)
            {
                if (tag.TagValue.HasIntValue)
                {
                    tagDict.Add(tag.GameTag, tag.TagValue);
                    switch (tag.GameTag)
                    {
                        case GameTag.COST:
                            Cost = tag.TagValue;
                            break;
                        case GameTag.ATK:
                            ATK = tag.TagValue;
                            break;
                        case GameTag.HEALTH:
                            Health = tag.TagValue;
                            break;
                        case GameTag.OVERLOAD:
                            HasOverload = true;
                            Overload = tag.TagValue;
                            break;
                        case GameTag.SPELLPOWER:
                            SpellPower = tag.TagValue;
                            break;
                        case GameTag.CHOOSE_ONE:
                            ChooseOne = true;
                            break;
                        case GameTag.COMBO:
                            Combo = true;
                            break;
                        case GameTag.TAUNT:
                            Taunt = true;
                            break;
                        case GameTag.CHARGE:
                            Charge = true;
                            break;
                        case GameTag.STEALTH:
                            Stealth = true;
                            break;
                        case GameTag.POISONOUS:
                            Poisonous = true;
                            break;
                        case GameTag.DIVINE_SHIELD:
                            DivineShield = true;
                            break;
                        case GameTag.WINDFURY:
                            Windfury = true;
                            break;
                        case GameTag.LIFESTEAL:
                            LifeSteal = true;
                            break;
                        case GameTag.ECHO:
                            Echo = true;
                            break;
                        case GameTag.RUSH:
                            Rush = true;
                            break;
                        case GameTag.CANT_BE_TARGETED_BY_SPELLS:
                            CantBeTargetedBySpells = true;
                            break;
                        case GameTag.CANT_ATTACK:
                            CantAttack = true;
                            break;
                        case GameTag.MODULAR:
                            Modular = true;
                            break;
                        case GameTag.SECRET:
                            IsSecret = true;
                            break;
                        case GameTag.QUEST:
                            IsQuest = true;
                            break;
                        case GameTag.DEATHRATTLE:
                            Deathrattle = true;
                            break;
                        case GameTag.UNTOUCHABLE:
                            Untouchable = true;
                            break;
                        case GameTag.HIDE_STATS:
                            HideStat = true;
                            break;
                        case GameTag.RECEIVES_DOUBLE_SPELLDAMAGE_BONUS:
                            ReceivesDoubleSpelldamageBonus = true;
                            break;
                        case GameTag.FREEZE:
                            Freeze = true;
                            break;
                        case GameTag.CARDRACE:
                            Race = (Race)(int)tag.TagValue;
                            break;
                        case GameTag.CLASS:
                            Class = (CardClass)(int)tag.TagValue;
                            break;
                        case GameTag.CARDTYPE:
                            Type = (CardType)(int)tag.TagValue;
                            break;
                    }
                }
                else if
                    (tag.TagValue.HasBoolValue)
                {
                    tagDict.Add(tag.GameTag, tag.TagValue ? 1 : 0);
                }
                else if
                    (tag.TagValue.HasStringValue)
                {
                    switch (tag.GameTag)
                    {
                        case GameTag.CARDNAME:
                            Name = tag.TagValue;
                            break;
                        case GameTag.CARDTEXT:
                            Text = tag.TagValue;
                            break;
                    }
                }
            }
            foreach (Tag tag in refTags)
            {
                if (refTagDict.ContainsKey(tag.GameTag))
                    continue;

                if (tag.TagValue.HasIntValue)
                {
                    refTagDict.Add(tag.GameTag, tag.TagValue);
                }
                else if (tag.TagValue.HasBoolValue)
                {
                    refTagDict.Add(tag.GameTag, tag.TagValue ? 1 : 0);
                }
            }
            #endregion

            #region Preprocessing requirements
            int characterType = 0;
            int friendlyCheck = 0;
            bool needsTarget = false;
            foreach (KeyValuePair<PlayReq, int> requirement in playRequirements)
            {
                switch (requirement.Key)
                {
                    case PlayReq.REQ_TARGET_TO_PLAY:
                        MustHaveTargetToPlay = true;
                        needsTarget = true;
                        break;
                    case PlayReq.REQ_DRAG_TO_PLAY:  // TODO
                    case PlayReq.REQ_NONSELF_TARGET:
                    case PlayReq.REQ_TARGET_IF_AVAILABLE:
                        needsTarget = true;
                        break;
                    case PlayReq.REQ_MINION_TARGET:
                        characterType = 1;
                        break;
                    case PlayReq.REQ_FRIENDLY_TARGET:
                        friendlyCheck = 1;
                        break;
                    case PlayReq.REQ_ENEMY_TARGET:
                        friendlyCheck = -1;
                        break;
                    case PlayReq.REQ_HERO_TARGET:
                        characterType = -1;
                        break;
                    case PlayReq.REQ_TARGET_WITH_RACE:
                        TargetingPredicate += TargetingPredicates.ReqTargetWithRace(requirement.Value);
                        break;
                    case PlayReq.REQ_FROZEN_TARGET:
                        TargetingPredicate += TargetingPredicates.ReqFrozenTarget;
                        break;
                    case PlayReq.REQ_DAMAGED_TARGET:
                        TargetingPredicate += TargetingPredicates.ReqDamagedTarget;
                        break;
                    case PlayReq.REQ_UNDAMAGED_TARGET:
                        TargetingPredicate += TargetingPredicates.ReqUndamagedTarget;
                        break;
                    case PlayReq.REQ_TARGET_MAX_ATTACK:
                        TargetingPredicate += TargetingPredicates.ReqTargetMaxAttack(requirement.Value);
                        break;
                    case PlayReq.REQ_TARGET_MIN_ATTACK:
                        TargetingPredicate += TargetingPredicates.ReqTargetMinAttack(requirement.Value);
                        break;
                    case PlayReq.REQ_MUST_TARGET_TAUNTER:
                        TargetingPredicate += TargetingPredicates.ReqMustTargetTaunter;
                        break;
                    case PlayReq.REQ_STEALTHED_TARGET:
                        TargetingPredicate += TargetingPredicates.ReqStealthedTarget;
                        break;
                    case PlayReq.REQ_TARGET_WITH_DEATHRATTLE:
                        TargetingPredicate += TargetingPredicates.ReqTargetWithDeathrattle;
                        break;
                    case PlayReq.REQ_LEGENDARY_TARGET:
                        TargetingPredicate += TargetingPredicates.ReqLegendaryTarget;
                        break;
                    case PlayReq.REQ_TARGET_FOR_COMBO:
                        needsTarget = true;
                        TargetingAvailabilityPredicate += TargetingPredicates.ReqTargetForCombo;
                        break;
                    case PlayReq.REQ_TARGET_IF_AVAILABE_AND_ELEMENTAL_PLAYED_LAST_TURN:
                        needsTarget = true;
                        TargetingAvailabilityPredicate += TargetingPredicates.ElementalPlayedLastTurn;
                        break;
                    case PlayReq.REQ_TARGET_IF_AVAILABLE_AND_DRAGON_IN_HAND:
                        needsTarget = true;
                        TargetingAvailabilityPredicate += TargetingPredicates.DragonInHand;
                        break;
                    case PlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_MINIONS:
                        needsTarget = true;
                        TargetingAvailabilityPredicate += TargetingPredicates.MinimumFriendlyMinions(requirement.Value);
                        break;
                    case PlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_SECRETS:
                        needsTarget = true;
                        TargetingAvailabilityPredicate += TargetingPredicates.MinimumFriendlySecrets(requirement.Value);
                        break;
                    case PlayReq.REQ_TARGET_IF_AVAILABLE_AND_NO_3_COST_CARD_IN_DECK:
                        // TODO
                        TargetingType = TargetingType.AllMinions;
                        break;
                    case PlayReq.REQ_NUM_MINION_SLOTS:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqNumMinionSlots;
                        break;
                    case PlayReq.REQ_MINIMUM_ENEMY_MINIONS:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqMinimumEnemyMinions(requirement.Value);
                        break;
                    case PlayReq.REQ_MINIMUM_TOTAL_MINIONS:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqMinimumTotalMinions(requirement.Value);
                        break;
                    case PlayReq.REQ_HAND_NOT_FULL:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqHandNotFull;
                        break;
                    case PlayReq.REQ_WEAPON_EQUIPPED:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqWeaponEquipped;
                        break;
                    case PlayReq.REQ_FRIENDLY_MINION_DIED_THIS_GAME:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqFriendlyMinionDiedThisGame;
                        break;
                    case PlayReq.REQ_MUST_PLAY_OTHER_CARD_FIRST:
                        PlayAvailabilityPredicate += c => false;
                        break;
                    //	REQ_STEADY_SHOT
                    //	REQ_MINION_OR_ENEMY_HERO	//	Steady Shot
                    //	REQ_MINION_SLOT_OR_MANA_CRYSTAL_SLOT	//	Jade Blossom
                    case PlayReq.REQ_SECRET_ZONE_CAP_FOR_NON_SECRET:
                        PlayAvailabilityPredicate += TargetingPredicates.ReqSecretZoneCapForNonSecret;
                        break;
                }
            }

            if (needsTarget)
            {
                if (characterType > 0)
                {
                    if (friendlyCheck == 0)
                        TargetingType = TargetingType.AllMinions;
                    else if (friendlyCheck == 1)
                        TargetingType = TargetingType.FriendlyMinions;
                    else
                        TargetingType = TargetingType.EnemyMinions;
                }
                else if (characterType == 0)
                {
                    if (friendlyCheck == 0)
                        TargetingType = TargetingType.All;
                    else if (friendlyCheck == 1)
                        TargetingType = TargetingType.FriendlyCharacters;
                    else
                        TargetingType = TargetingType.EnemyCharacters;
                }
                else
                    TargetingType = TargetingType.Heroes;
            }
            #endregion

            Tags = tagDict;
            RefTags = refTagDict;
            // spell damage information add ... 
            if (Text != null && (Text.Contains("$") || tagDict.ContainsKey(GameTag.AFFECTED_BY_SPELL_POWER)))
            {
                Text += " @spelldmg";
                IsAffectedBySpellDamage = true;
            }
        }
    }
}
