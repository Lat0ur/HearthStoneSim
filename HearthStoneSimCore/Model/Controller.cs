using System.Collections.Generic;
using HearthStoneSimCore.Enums;
using HearthStoneSimCore.Model.Zones;

namespace HearthStoneSimCore.Model
{
    public class Controller : Core
    {
	    public string FriendlyName { get; }
	    
	    /// <summary>
	    /// The hero entity representing this player.
	    /// </summary>
	    public Hero Hero { get; set; }
        
	    /// <summary>
        /// The deck of this player.
        /// This zone contains cards which are not yet drawn. Can be empty.
        /// </summary>
        public DeckZone DeckZone { get; private set; }

        /// <summary>
        /// The hand of this player.
        /// This zone contains cards which were drawn from deck or generated.
        /// during the game. Can be empty.
        /// </summary>
        public HandZone HandZone { get; private set; }

        /// <summary>
        /// The minions friendly to this player.
        /// This zone contains all minion entities generated by cards from the hand.
        /// Can be empty.
        /// </summary>
        public BoardZone BoardZone { get; private set; }

        /// <summary>
        /// The zone containing all entities which were once in play, but now destroyed. Can be empty.
        /// </summary>
        public GraveyardZone GraveyardZone;

        /// <summary>
        /// The zone containing all played secrets by this player. Can be empty.
        /// </summary>
        public SecretZone SecretZone { get; private set; }

        /// <summary>
        /// The opponent player instance.
        /// </summary>
        public Controller Opponent => Game.Player1 == this ? Game.Player2 : Game.Player1;

        #region Mana
        /// <summary>
        /// Total amount of mana available to this player.
        /// This value DOES NOT contain temporary mana!
        /// This value is limited to 1 turn and should be reset in the next turn.
        /// </summary>
        public int BaseMana
        {
            get => this[GameTag.RESOURCES];
            set => this[GameTag.RESOURCES] = value;
        }

        /// <summary>
        /// Additionall mana gained during this turn.
        /// </summary>
        public int TemporaryMana
        {
            get => this[GameTag.TEMP_RESOURCES];
            set => this[GameTag.TEMP_RESOURCES] = value;
        }

        /// <summary>
        /// Amount of mana used by this player.
        /// 
        /// This value is limited to 1 turnand should be reset in the next turn.
        /// </summary>
        public int UsedMana
        {
            get => this[GameTag.RESOURCES_USED];
            set => this[GameTag.RESOURCES_USED] = value;
        }

        /// <summary>
        /// Amount of mana crystals which will be locked during the next turn.
        /// </summary>
        public int OverloadOwed
        {
            get => this[GameTag.OVERLOAD_OWED];
            set => this[GameTag.OVERLOAD_OWED] = value;
        }

        /// <summary>
        /// Amount of mana crystals locked this turn.
        /// 
        /// The subtraction of BASE_MANA and this value gives the available
        /// resources during this turn.
        /// </summary>
        public int OverloadLocked
        {
            get => this[GameTag.OVERLOAD_LOCKED];
            set => this[GameTag.OVERLOAD_LOCKED] = value;
        }

        /// <summary>
        /// The amount of mana available to actually use after calculating all resource factors.
        /// </summary>
        public int RemainingMana => BaseMana + TemporaryMana - (UsedMana + OverloadLocked);

        public int TotalManaSpentThisGame
        {
            get => this[GameTag.NUM_RESOURCES_SPENT_THIS_GAME];
            set => this[GameTag.NUM_RESOURCES_SPENT_THIS_GAME] = value;
        }
        #endregion Mana

        /// <summary>
        /// Amount of current Spell Damage bonus for this Controller.
        /// </summary>
        public int CurrentSpellPower { get; set; }

        public int NumCardsPlayedThisTurn
	    {
		    get => this[GameTag.NUM_CARDS_PLAYED_THIS_TURN];
		    set => this[GameTag.NUM_CARDS_PLAYED_THIS_TURN] = value;
	    }

        public int NumCardsDrawnThisTurn
        {
            get => this[GameTag.NUM_CARDS_DRAWN_THIS_TURN];
            set => this[GameTag.NUM_CARDS_DRAWN_THIS_TURN] = value;
        }

        public int LastCardDrawn
        {
            get => this[GameTag.LAST_CARD_DRAWN];
            set => this[GameTag.LAST_CARD_DRAWN] = value;
        }

        public int NumMinionsPlayedThisTurn
	    {
		    get => this[GameTag.NUM_MINIONS_PLAYED_THIS_TURN];
		    set => this[GameTag.NUM_MINIONS_PLAYED_THIS_TURN] = value;
	    }

	    public int NumElementalsPlayedLastTurn
	    {
		    get => this[GameTag.NUM_ELEMENTAL_PLAYED_LAST_TURN];
		    set => this[GameTag.NUM_ELEMENTAL_PLAYED_LAST_TURN] = value;
	    }

        public int NumOptionsPlayedThisTurn
        {
            get => this[GameTag.NUM_OPTIONS_PLAYED_THIS_TURN];
            set => this[GameTag.NUM_OPTIONS_PLAYED_THIS_TURN] = value;
        }

        public int LastCardPlayed
        {
            get => this[GameTag.LAST_CARD_PLAYED];
            set => this[GameTag.LAST_CARD_PLAYED] = value;
        }

        public int NumFriendlyMinionsThatAttackedThisTurn
        {
            get => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN];
            set => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN] = value;
        }
        /// <summary>
        /// Indicates if combo enchantment effects of next cards should be executed or not.
        /// 
        /// Combo is active if at least one card has been played this turn.
        /// </summary>
        public bool IsComboActive
	    {
		    get => this[GameTag.COMBO_ACTIVE] == 1;
		    set => this[GameTag.COMBO_ACTIVE] = value ? 1 : 0;
	    }

		public Controller(Game game, string name, int playerId, Dictionary<GameTag, int> tags) : base(game, Card.CardPlayer, tags)
        {
	        FriendlyName = name;
			Game = game;
            DeckZone = new DeckZone(this);
            HandZone = new HandZone(this);
            BoardZone = new BoardZone(this);
			SecretZone = new SecretZone(this);
            GraveyardZone = new GraveyardZone(this);

            Game.Log(LogLevel.INFO, BlockType.PLAY, "Controller", $"Created Controller '{name}'");
        }
	}
}
