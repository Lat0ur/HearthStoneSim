using System;
using System.Collections.Generic;
using HearthStoneSimCore.Actions;
using HearthStoneSimCore.Enums;
using HearthStoneSimCore.Model.Utils;
using HearthStoneSimCore.Model.Zones;
using System.Linq;
using HearthStoneSimCore.Model.Factory;

namespace HearthStoneSimCore.Model
{
    public class Controller
    {
	    public string Name { get; }
        public Game Game { get; }
        public Dictionary<GameTag, int> Tags { get; }

        public int this[GameTag tag]
        {
            get => Tags.TryGetValue(tag, out int value) ? value : 0;
            set => Tags[tag] = value;
        }

        /// <summary>
        /// Base class of the controller.
        /// </summary>
        public CardClass BaseClass { get; internal set; }

        /// <summary>
        /// The hero entity representing this player.
        /// </summary>
        public Hero Hero { get; set; }

        /// <summary>
        /// The cardclass of the deck.
        /// Only neutral cards and cards specific to this class are allowed in the starting deck
        /// of the player.
        /// </summary>
        public CardClass HeroClass => Hero.Card.Class;

        /// <summary>
        /// All standard cards which can be put into a deck of this class.
        /// </summary>
        public IReadOnlyList<Card> Standard => Cards.Standard[HeroClass];

        /// <summary>
        /// Initial cards that are in the deck of the controller.
        /// </summary>
        public List<Card> DeckCards { get; internal set; } = new List<Card>();

        /// <summary>
        /// The deck of this player.
        /// This zone contains cards which are not yet drawn. Can be empty.
        /// </summary>
        public DeckZone Deck { get; private set; }

        /// <summary>
        /// The hand of this player.
        /// This zone contains cards which were drawn from deck or generated.
        /// during the game. Can be empty.
        /// </summary>
        public HandZone Hand { get; private set; }

        /// <summary>
        /// The minions friendly to this player.
        /// This zone contains all minion entities generated by cards from the hand.
        /// Can be empty.
        /// </summary>
        public BoardZone Board { get; private set; }

        /// <summary>
        /// The zone containing all entities which were once in play, but now destroyed. Can be empty.
        /// </summary>
        public GraveyardZone Graveyard;

        /// <summary>
        /// The zone containing all played secrets by this player. Can be empty.
        /// </summary>
        public SecretZone Secret { get; private set; }

        /// <summary>
        /// The opponent player instance.
        /// </summary>
        public Controller Opponent => Game.Player1 == this ? Game.Player2 : Game.Player1;

        #region Mana Property
        /// <summary>
        /// Total amount of mana available to this player.
        /// This value DOES NOT contain temporary mana!
        /// This value is limited to 1 turn and should be reset in the next turn.
        /// </summary>
        public int BaseMana
        {
            get => this[GameTag.RESOURCES];
            set => this[GameTag.RESOURCES] = value;
        }

        /// <summary>
        /// Additionall mana gained during this turn.
        /// </summary>
        public int TemporaryMana
        {
            get => this[GameTag.TEMP_RESOURCES];
            set => this[GameTag.TEMP_RESOURCES] = value;
        }

        /// <summary>
        /// Amount of mana used by this player.
        /// 
        /// This value is limited to 1 turnand should be reset in the next turn.
        /// </summary>
        public int UsedMana
        {
            get => this[GameTag.RESOURCES_USED];
            set => this[GameTag.RESOURCES_USED] = value;
        }

        /// <summary>
        /// Amount of mana crystals which will be locked during the next turn.
        /// </summary>
        public int OverloadOwed
        {
            get => this[GameTag.OVERLOAD_OWED];
            set => this[GameTag.OVERLOAD_OWED] = value;
        }

        /// <summary>
        /// Amount of mana crystals locked this turn.
        /// 
        /// The subtraction of BASE_MANA and this value gives the available
        /// resources during this turn.
        /// </summary>
        public int OverloadLocked
        {
            get => this[GameTag.OVERLOAD_LOCKED];
            set => this[GameTag.OVERLOAD_LOCKED] = value;
        }

        /// <summary>
        /// The amount of mana available to actually use after calculating all resource factors.
        /// </summary>
        public int RemainingMana => BaseMana + TemporaryMana - (UsedMana + OverloadLocked);

        public int TotalManaSpentThisGame
        {
            get => this[GameTag.NUM_RESOURCES_SPENT_THIS_GAME];
            set => this[GameTag.NUM_RESOURCES_SPENT_THIS_GAME] = value;
        }
        #endregion Mana Property

        /// <summary>
        /// Amount of current Spell Damage bonus for this Controller.
        /// </summary>
        public int CurrentSpellPower { get; set; }

        public int NumCardsPlayedThisTurn
	    {
		    get => this[GameTag.NUM_CARDS_PLAYED_THIS_TURN];
		    set => this[GameTag.NUM_CARDS_PLAYED_THIS_TURN] = value;
	    }

        public int NumCardsDrawnThisTurn
        {
            get => this[GameTag.NUM_CARDS_DRAWN_THIS_TURN];
            set => this[GameTag.NUM_CARDS_DRAWN_THIS_TURN] = value;
        }

        public int LastCardDrawn
        {
            get => this[GameTag.LAST_CARD_DRAWN];
            set => this[GameTag.LAST_CARD_DRAWN] = value;
        }

        public int NumMinionsPlayedThisTurn
	    {
		    get => this[GameTag.NUM_MINIONS_PLAYED_THIS_TURN];
		    set => this[GameTag.NUM_MINIONS_PLAYED_THIS_TURN] = value;
	    }

	    public int NumElementalsPlayedLastTurn
	    {
		    get => this[GameTag.NUM_ELEMENTAL_PLAYED_LAST_TURN];
		    set => this[GameTag.NUM_ELEMENTAL_PLAYED_LAST_TURN] = value;
	    }

        public int NumOptionsPlayedThisTurn
        {
            get => this[GameTag.NUM_OPTIONS_PLAYED_THIS_TURN];
            set => this[GameTag.NUM_OPTIONS_PLAYED_THIS_TURN] = value;
        }

        public int LastCardPlayed
        {
            get => this[GameTag.LAST_CARD_PLAYED];
            set => this[GameTag.LAST_CARD_PLAYED] = value;
        }

        public int NumFriendlyMinionsThatDiedThisTurn
        {
            get => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_TURN];
            set => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_TURN] = value;
        }

        public int NumMinionsPlayerKilledThisTurn
        {
            get => this[GameTag.NUM_MINIONS_PLAYER_KILLED_THIS_TURN];
            set => this[GameTag.NUM_MINIONS_PLAYER_KILLED_THIS_TURN] = value;
        }

        public int NumFriendlyMinionsThatAttackedThisTurn
        {
            get => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN];
            set => this[GameTag.NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN] = value;
        }

        /// <summary>
        /// Indicates if combo enchantment effects of next cards should be executed or not.
        /// 
        /// Combo is active if at least one card has been played this turn.
        /// </summary>
        public bool IsComboActive
	    {
		    get => this[GameTag.COMBO_ACTIVE] == 1;
		    set => this[GameTag.COMBO_ACTIVE] = value ? 1 : 0;
	    }

        /// <summary>
        /// Returns true if this player has a dragon in his hand.
        /// </summary>
        public bool DragonInHand => Hand.Any(p => p.Card.Race == Race.DRAGON);

        public bool MinionAttack(Minion source, Character target)
        {
            GameAction.AttackBlock(this, source, target);
            return true;
        }

        public bool PlayCard(Playable source, Character target = null, int zonePosition = -1, int chooseOne = 0)
        {
            GameAction.PlayCardBlock(this, source, target, zonePosition, chooseOne);
            Game.StateChanged = true;
            return true;
        }

        public void FillDeck()
        {
            int cardsToAdd = DeckZone.StartingCards;

            Game.Log(LogLevel.INFO, BlockType.PLAY, "Deck",
                $"Deck from {Name} filling up with {cardsToAdd} random cards.");
            while (cardsToAdd > 0)
            {
                Card card = ThreadLocalRandom.Choose(Standard);

                // don't add cards that have already reached max occurence in deck.
                if (Deck.Count(c => c.Card == card) >= card.MaxAllowedInDeck)
                    continue;

                DeckCards.Add(card);

                Playable playable = CardFactory.FromCard(this, card);
                Deck.Add(playable);
                
                cardsToAdd--;
            }
        }

        public Controller(Game game, string name, int playerId, CardClass hero, Dictionary<GameTag, int> tags = null)
        {
	        Name = name;
			Game = game;
            Tags = tags ?? new Dictionary<GameTag, int>(Enum.GetNames(typeof(GameTag)).Length);

            Deck = new DeckZone(this);
            Hand = new HandZone(this);
            Board = new BoardZone(this);
			Secret = new SecretZone(this);
            Graveyard = new GraveyardZone(this);

            BaseClass = hero;
            Card heroCard = Cards.HeroCard(BaseClass);
            Hero = (Hero) CardFactory.FromCard(this, heroCard);

            Game.Log(LogLevel.INFO, BlockType.PLAY, "Controller", $"Created Controller '{name}'");
        }
	}
}
